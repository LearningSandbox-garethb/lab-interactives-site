<!DOCTYPE html>
<html>
  <head>
    <meta content='text/html;charset=utf-8' http-equiv='Content-Type'>
    <meta content='IE=edge,chrome=1' http-equiv='X-UA-Compatible'>
    <script src="../vendor/jquery/jquery.min.js" type="text/javascript"></script>
  </head>
  <body>
  	<h2>JSFiddle Creation Tool</h2>
    Currently this doesn't work. All of the css and script tags in the template html file need to be converted to
    fiddle 'resources', and passed in the resources parameter. 
    Also all script tags in the html need either be external scripts or put into the js parameter.
    And also some of the resources referenced by the template html are relative, so those need to be made absolute.

    Notes on various parameters are here:
    http://doc.jsfiddle.net/api/post.html

  	<p>
  		NOTE: If the interactive or model has resources it references (like images) you will need to track those down and
  		put them in the appropriate place.
    </p>
<form method='post' action='http://jsfiddle.net/api/post/library/pure/' target='check'>
    <p><input type='submit'/> - fiddle will be loaded in different browser window/tab.</p>
    <label>HTML:</label>
    <textarea name='html' id='fiddle-html'></textarea>
    <label>JavaScript:</label>
    <textarea name='js' id='fiddle-js'></textarea>
    <label>Title:</label>
    <input type='text' name='title' id='fiddle-title' value='some title'/>
    <label>Description:</label>
    <textarea name='description' id='fiddle-description'></textarea>
    <label>DTD:</label>
    <input type='text' name='dtd' value='html 4'/>
    <label>Wrap (l/d/h/b)</label>
    <input type='text' name='wrap' value='l'/>
</form>
  	<script>
  	  (function (){
        var template_html,
            interactive,
            promises = [],
            hash = window.location.hash;

        $(window).bind('hashchange', function() {
          if (document.location.hash !== hash) {
            location.reload();
          }
        });

        // download standalone-template/template.html
        // download the interactive specified in the hash
        // download the model files and replace their references in the interactive
        // inject the interactive into the template
        // serialize the whole thing into the textarea
        function getHomeForSharing() {
            var protocol = window.location.protocol;
            var host     = window.location.host;
            var pathname = window.location.pathname;
            return protocol + "//" + host + pathname.replace("/standalone/jsfiddle.html", "");
        }

        promises.push($.get("jsfiddle-template.html", function(results){
          // $('#fiddle-html').html(results);
        }));
        $.getJSON("../" + window.location.hash.substring(1)).done(function(results){
          	interactive = results;
          	console.log("found " + interactive.models.length + " models");
          	$.each(interactive.models, function(index, model){
          		if(model.url){
            		console.log("downloading model: " + model.url);
          			var modelPromise = $.getJSON("../" + model.url).done(function(results){
          				delete model.url;
          				model.model = results;
          			});
          			promises.push(modelPromise);
          		}
          	});

          	$.when.apply($,promises).then(function() {
  	          var interactive_def,
  	      	      inlined,
  	      	      blob, blob_url;
  	      	  interactive_def = "window.INTERACTIVE=" + 
  	      	    JSON.stringify(interactive, null, 2) + 
  	      	    ";"

              $('#fiddle-js').html(interactive_def + "\nloadFiddleInteractive();");
            });
        });
  	  })();

  	  // possible improvements:

  	  // use blob urls with a dynamically created link with a download attribute so the 
  	  // user just needs to click the link to save the constructed template.html

  	  // use a javascript zip library to constructure a full zip file client side that includes
  	  // the interactive plus all of its resources. this would mean a multi mega byte blob
  	  // though which might tax the browser memory

  	  // make a heroku app that can do the zip file combining for us:
  	  // - you send the app a json struct with a base zip url
  	  // - a set of additional "files" to add to base zip (with inline content)

  	  // these approaches aren't going to handle the case where the model or interactive references
  	  // resources like images, we'd need to search the interactive and model files for these and either
  	  // inline them or if we had the zip file support we could add them to the zip
  	</script>
  </body>
</html>